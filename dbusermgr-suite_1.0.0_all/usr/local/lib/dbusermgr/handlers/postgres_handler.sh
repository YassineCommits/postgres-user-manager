#!/bin/bash
# lib/dbusermgr/handlers/postgres_handler.sh
UTILS_SCRIPT_PATH="/usr/local/lib/dbusermgr/utils.sh" 
if [ -f "$UTILS_SCRIPT_PATH" ]; then source "$UTILS_SCRIPT_PATH"; else echo "[FATAL] PG Handler: utils.sh missing at $UTILS_SCRIPT_PATH" >&2; exit 127; fi
pg_exec_psql(){ local s="$1" c="$2" au="$3" ap="$4" d="$5" st; log_debug "pg_exec: C='${c}' AU='${au}' DBN='${d}' SQL='${s}'"; if ! command_exists docker; then log_error "Docker missing."; return 127; fi; local cmd=("docker" "exec" "-i"); if [ -n "$ap" ]; then cmd+=("-e" "PGPASSWORD=${ap}"); fi; cmd+=("$c" "psql" "-U" "$au" "-d" "$d" "-v" ON_ERROR_STOP=1 -c "$s"); log_info "Exec: ${cmd[*]}"; "${cmd[@]}"; st=$?; if [ $st -ne 0 ]; then log_error "psql fail: $st."; else log_info "psql ok."; fi; return $st; }
pg_create_user(){ log_info "PG: Create"; local u="" p="" askp=false so=NOSUPERUSER co=NOCREATEDB cro=NOCREATEROLE lo=LOGIN; local c="$1" au="$2" apass="$3" dc="$4"; shift 4; while [[ $# -gt 0 ]]; do case "$1" in --username) u="$2";shift 2;; --password) p="$2";shift 2;; --ask-password) askp=true;shift;; --superuser) so=SUPERUSER;shift;; --no-superuser) so=NOSUPERUSER;shift;; --createdb) co=CREATEDB;shift;; --no-createdb) co=NOCREATEDB;shift;; --createrole) cro=CREATEROLE;shift;; --no-createrole) cro=NOCREATEROLE;shift;; --login) lo=LOGIN;shift;; --no-login) lo=NOLOGIN;shift;; *) log_error "pg_create: Unk: $1"; return 1;; esac; done; if [ -z "$u" ]; then log_error "--user req."; return 1; fi; if $askp && [ -n "$p" ]; then log_warn "Using --pass."; elif $askp; then if ! get_password p "Pass for PG '$u' (cont '$c')"; then return 1; fi; elif [ -z "$p" ]; then log_error "Pass req."; return 1; fi; local opts=("$lo" "$so" "$co" "$cro" "PASSWORD '$p'"); local sql="CREATE USER \"$u\" WITH ${opts[*]};"; pg_exec_psql "$sql" "$c" "$au" "$apass" "$dc"; return $?; }
pg_list_users(){ log_info "PG: List"; local c="$1" au="$2" apass="$3" dc="$4"; local sql="SELECT usename AS \"User Name\", CASE WHEN usesuper AND usecreatedb THEN 'Superuser, Create DB' WHEN usesuper THEN 'Superuser' WHEN usecreatedb THEN 'Create DB' ELSE 'Standard User' END AS \"User Type\", CASE WHEN valuntil IS NOT NULL THEN 'Expires: ' || valuntil ELSE 'No Expiry' END AS \"Password Validity\" FROM pg_user ORDER BY usename;"; pg_exec_psql "$sql" "$c" "$au" "$apass" "$dc"; return $?; }
pg_delete_user(){ log_info "PG: Delete"; local c="$1" au="$2" apass="$3" dc="$4"; shift 4; local u="" ife="" sc=false; while [[ $# -gt 0 ]]; do case "$1" in --username) u="$2";shift 2;; --if-exists) ife="IF EXISTS";shift;; --yes) sc=true;shift;; *) log_error "pg_delete: Unk: $1"; return 1;; esac; done; if [ -z "$u" ]; then log_error "--user req."; return 1; fi; if ! $sc && [ -t 0 ]; then read -r -p "Delete '$u' in '$c'? (yes/N): " conf; if [[ "$conf" != "yes" ]]; then log_info "Cancelled."; return 0; fi; fi; local sql="DROP USER $ife \"$u\";"; pg_exec_psql "$sql" "$c" "$au" "$apass" "$dc"; return $?; }
pg_alter_user(){ log_info "PG: Alter"; local u="" np="" asknp=false rn="" ao=(); local c="$1" au="$2" apass="$3" dc="$4"; shift 4; while [[ $# -gt 0 ]]; do case "$1" in --username) u="$2";shift 2;; --new-password) np="$2";shift 2;; --ask-new-password) asknp=true;shift;; --rename-to) rn="$2";shift 2;; --superuser) ao+=("SUPERUSER");shift;; --no-superuser) ao+=("NOSUPERUSER");shift;; --createdb) ao+=("CREATEDB");shift;; --no-createdb) ao+=("NOCREATEDB");shift;; --createrole) ao+=("CREATEROLE");shift;; --no-createrole) ao+=("NOCREATEROLE");shift;; --login) ao+=("LOGIN");shift;; --no-login) ao+=("NOLOGIN");shift;; *) log_error "pg_alter: Unk: $1"; return 1;; esac; done; if [ -z "$u" ]; then log_error "--user req."; return 1; fi; if $asknp && [ -n "$np" ]; then log_warn "Using --new-pass."; elif $asknp; then if ! get_password np "New pass for PG '$u' (cont '$c')"; then return 1; fi; fi; if [ -n "$np" ]; then ao+=("PASSWORD '$np'"); fi; local os=0; if [ ${#ao[@]} -gt 0 ]; then local aos="$(IFS=' '; echo "${ao[*]}")"; local sql="ALTER USER \"$u\" WITH $aos;"; pg_exec_psql "$sql" "$c" "$au" "$apass" "$dc"; if [ $? -ne 0 ]; then os=1; fi; fi; if [ -n "$rn" ]; then local sql="ALTER USER \"$u\" RENAME TO \"$rn\";"; pg_exec_psql "$sql" "$c" "$au" "$apass" "$dc"; if [ $? -ne 0 ]; then os=1; else u="$rn"; fi; fi; if [ ${#ao[@]} -eq 0 ] && [ -z "$rn" ]; then log_error "No alteration for '$u'."; return 1; fi; if [ $os -eq 0 ]; then log_info "User '$u' altered."; else log_error "Fail alter '$u'."; fi; return $os; }
pg_grant_privs(){ log_info "PG: Grant"; local u="" odb="" privs="" ot="" oaa="" os="" oaas="" wgo=""; local c="$1" au="$2" apass="$3" dca="$4"; shift 4; while [[ $# -gt 0 ]]; do case "$1" in --username) u="$2";shift 2;; --on-db) odb="$2";shift 2;; --privileges) privs="$2";shift 2;; --on-table) ot="$2";shift 2;; --on-all-tables-in-schema) oaa="$2";shift 2;; --on-schema) os="$2";shift 2;; --on-all-sequences-in-schema) oaas="$2";shift 2;; --with-grant-option) wgo="WITH GRANT OPTION";shift;; *) log_error "pg_grant: Unk: $1";return 1;;esac;done; if [ -z "$u" ]||[ -z "$odb" ]||[ -z "$privs" ]; then log_error "--user, --on-db, --privs req.";return 1;fi; local to=""; local tdb="$odb"; if [ -n "$ot" ];then to="TABLE \"$ot\"";elif [ -n "$oaa" ];then to="ALL TABLES IN SCHEMA \"$oaa\"";elif [ -n "$os" ];then to="SCHEMA \"$os\"";elif [ -n "$oaas" ];then to="ALL SEQUENCES IN SCHEMA \"$oaas\"";else to="DATABASE \"$odb\""; local vp="CREATE,CONNECT,TEMPORARY,TEMP"; if [[ "${privs^^}" != "ALL PRIVILEGES" ]]; then local fp=""; IFS=',' read -ra pa <<< "$privs"; for p in "${pa[@]}"; do if [[ "$vp" == *"${p^^}"* ]]; then fp="${fp}${p},"; else log_warn "Priv '$p' ? DB level.";fp="${fp}${p},"; fi; done; privs=${fp%,}; if [ -z "$privs" ]; then log_error "No valid DB privs."; return 1; fi; fi; fi; local sql="GRANT ${privs} ON ${to} TO \"$u\" ${wgo};"; pg_exec_psql "$sql" "$c" "$au" "$apass" "$tdb"; return $?; }
pg_revoke_privs(){ log_info "PG: Revoke"; local u="" odb="" privs="" ot="" oaa="" os="" oaas="" casc=""; local c="$1" au="$2" apass="$3" dca="$4"; shift 4; while [[ $# -gt 0 ]]; do case "$1" in --username) u="$2";shift 2;; --on-db) odb="$2";shift 2;; --privileges) privs="$2";shift 2;; --on-table) ot="$2";shift 2;; --on-all-tables-in-schema) oaa="$2";shift 2;; --on-schema) os="$2";shift 2;; --on-all-sequences-in-schema) oaas="$2";shift 2;; --cascade) casc="CASCADE";shift;; *) log_error "pg_revoke: Unk: $1";return 1;;esac;done; if [ -z "$u" ]||[ -z "$odb" ]||[ -z "$privs" ]; then log_error "--user, --on-db, --privs req.";return 1;fi; local to=""; local tdb="$odb"; if [ -n "$ot" ];then to="TABLE \"$ot\"";elif [ -n "$oaa" ];then to="ALL TABLES IN SCHEMA \"$oaa\"";elif [ -n "$os" ];then to="SCHEMA \"$os\"";elif [ -n "$oaas" ];then to="ALL SEQUENCES IN SCHEMA \"$oaas\"";else to="DATABASE \"$odb\"";fi; local sql="REVOKE ${privs} ON ${to} FROM \"$u\" ${casc};"; pg_exec_psql "$sql" "$c" "$au" "$apass" "$tdb"; return $?; }
handle_postgres_command(){ local c="$1" au="$2" apass="$3" dc="$4" cmd="$5"; shift 5; log_debug "PG Hdlr: C='${c}', AU='${au}', DBN='${dc}', Cmd='${cmd}'"; case "$cmd" in create-user)pg_create_user "$c" "$au" "$apass" "$dc" "$@";;list-users)pg_list_users "$c" "$au" "$apass" "$dc" "$@";;delete-user)pg_delete_user "$c" "$au" "$apass" "$dc" "$@";;alter-user)pg_alter_user "$c" "$au" "$apass" "$dc" "$@";;grant-privs)pg_grant_privs "$c" "$au" "$apass" "$dc" "$@";;revoke-privs)pg_revoke_privs "$c" "$au" "$apass" "$dc" "$@";;*)log_error "PG Hdlr: Unk cmd '$cmd'";return 127;;esac;return $?; }
